/**
 * Utility functions for extracting CVE IDs from text and computing error impacts/solutions
 */

/**
 * Extract CVE IDs from text using regex pattern matching
 * @param text - The text to search for CVE IDs
 * @returns Array of unique CVE IDs found (uppercase)
 */
export function extractCveIds(text: string): string[] {
  if (!text) return [];
  const cvePattern = /CVE-\d{4}-\d{4,}/gi;
  const matches = text.match(cvePattern);
  return matches ? [...new Set(matches.map((m) => m.toUpperCase()))] : [];
}

/**
 * Extract CWE IDs from text using regex pattern matching
 * @param text - The text to search for CWE IDs
 * @returns Array of unique CWE IDs found (uppercase)
 */
export function extractCweIds(text: string): string[] {
  if (!text) return [];
  const cwePattern = /CWE-\d{1,4}/gi;
  const matches = text.match(cwePattern);
  return matches ? [...new Set(matches.map((m) => m.toUpperCase()))] : [];
}

/**
 * Extract the first CVE ID from text, or return null
 * @param text - The text to search
 * @returns First CVE ID found or null
 */
export function extractFirstCveId(text: string): string | null {
  const cves = extractCveIds(text);
  return cves.length > 0 ? cves[0] : null;
}

/**
 * Extract the first CWE ID from text, or return null
 * @param text - The text to search
 * @returns First CWE ID found or null
 */
export function extractFirstCweId(text: string): string | null {
  const cwes = extractCweIds(text);
  return cwes.length > 0 ? cwes[0] : null;
}

/**
 * Compute the impact level of a tool error based on phase and status
 * @param phase - The scan phase (e.g., 'VULNERABILITY_SCANNING')
 * @param status - The step status (e.g., 'FAILED', 'TIMEOUT')
 * @param tool - Optional tool name for context
 * @returns Impact level: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
 */
export function computeErrorImpact(
  phase: string,
  status: string,
  tool?: string,
): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
  // Critical phases where failures have high impact
  const criticalPhases = ['VULNERABILITY_SCANNING', 'EXPLOITATION_CHAIN'];
  const importantPhases = ['DEEP_RECONNAISSANCE', 'AUTOMATED_SCAN'];

  if (status === 'FAILED') {
    if (criticalPhases.includes(phase)) {
      return 'CRITICAL';
    }
    if (importantPhases.includes(phase)) {
      return 'HIGH';
    }
    return 'MEDIUM';
  }

  if (status === 'TIMEOUT') {
    if (criticalPhases.includes(phase)) {
      return 'HIGH';
    }
    return 'MEDIUM';
  }

  if (status === 'SKIPPED') {
    return 'LOW';
  }

  // PARTIAL or WARNING status
  return 'LOW';
}

/**
 * Generate a suggested solution based on error type and context
 * @param status - The step status
 * @param error - The error message
 * @param tool - Optional tool name
 * @returns Suggested solution string
 */
export function generateErrorSolution(
  status: string,
  error: string | null,
  tool?: string,
): string {
  const errorLower = (error || '').toLowerCase();

  if (status === 'TIMEOUT') {
    return 'Augmenter le timeout ou r\u00e9duire la port\u00e9e du scan';
  }

  if (status === 'FAILED') {
    if (errorLower.includes('connection') || errorLower.includes('connect')) {
      return 'V\u00e9rifier la connectivit\u00e9 r\u00e9seau et l\'accessibilit\u00e9 de la cible';
    }
    if (errorLower.includes('permission') || errorLower.includes('access denied')) {
      return 'V\u00e9rifier les permissions et les credentials';
    }
    if (errorLower.includes('not found') || errorLower.includes('404')) {
      return 'V\u00e9rifier que la cible existe et est accessible';
    }
    if (errorLower.includes('timeout')) {
      return 'Augmenter le timeout ou v\u00e9rifier la stabilit\u00e9 du r\u00e9seau';
    }
    if (errorLower.includes('memory') || errorLower.includes('oom')) {
      return 'R\u00e9duire la port\u00e9e du scan ou augmenter les ressources';
    }
    return 'V\u00e9rifier la configuration de l\'outil et r\u00e9essayer';
  }

  if (status === 'SKIPPED') {
    return '\u00c9tape ignor\u00e9e suite \u00e0 une d\u00e9cision du workflow';
  }

  // PARTIAL or other
  return 'R\u00e9sultats partiels - envisager une nouvelle ex\u00e9cution pour des r\u00e9sultats complets';
}

/**
 * Extract location/target information from various tool outputs
 * @param output - Tool output text
 * @param target - Original target
 * @returns Extracted location or null
 */
export function extractLocation(output: string, target: string): string | null {
  if (!output) return null;

  // Try to extract URL paths
  const urlPathMatch = output.match(/(?:GET|POST|PUT|DELETE)\s+([^\s]+)/i);
  if (urlPathMatch) {
    return urlPathMatch[1];
  }

  // Try to extract port information
  const portMatch = output.match(/(\d{1,5})\/(?:tcp|udp)\s+open/i);
  if (portMatch) {
    return `${target}:${portMatch[1]}`;
  }

  // Try to extract file paths
  const filePathMatch = output.match(/(?:file|path):\s*([^\s\n]+)/i);
  if (filePathMatch) {
    return filePathMatch[1];
  }

  return null;
}

/**
 * Map step status to display status for the UI
 * @param status - The database status
 * @returns Display status for UI
 */
export function mapStepStatusToDisplayStatus(
  status: string,
): 'SUCCESS' | 'TIMEOUT' | 'FAILED' | 'WARNING' | 'PARTIAL' | 'PENDING' | 'RUNNING' {
  switch (status) {
    case 'COMPLETED':
      return 'SUCCESS';
    case 'TIMEOUT':
      return 'TIMEOUT';
    case 'FAILED':
      return 'FAILED';
    case 'SKIPPED':
      return 'WARNING';
    case 'PENDING':
      return 'PENDING';
    case 'RUNNING':
      return 'RUNNING';
    default:
      return 'PARTIAL';
  }
}
